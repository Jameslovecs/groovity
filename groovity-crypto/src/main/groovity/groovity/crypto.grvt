/*******************************************************************************
 * Â© 2018 Disney | ABC Television Group
 *
 * Licensed under the Apache License, Version 2.0 (the "Apache License")
 * with the following modification; you may not use this file except in
 * compliance with the Apache License and the following modification to it:
 * Section 6. Trademarks. is deleted and replaced with:
 *
 * 6. Trademarks. This License does not grant permission to use the trade
 *     names, trademarks, service marks, or product names of the Licensor
 *     and its affiliates, except as required to comply with Section 4(c) of
 *     the License and to reproduce the content of the NOTICE file.
 *
 * You may obtain a copy of the Apache License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the Apache License with the above modification is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the Apache License for the specific
 * language governing permissions and limitations under the Apache License.
 *******************************************************************************/

import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
import static javax.xml.bind.DatatypeConverter.parseHexBinary;
 
/**
 * Basic re-usable crypto lib, useful for example to encrypt sensitive values stored in a database
 *
 * @author Alex Vigdor
 */

static conf=[
	//hex-encoded 16 byte key for 128 bit encryption, generated by a secure random function
	DEFAULT_CRYPTO_KEY : "",
	//encryption cipher, default is sensible
	DEFAULT_CRYPTO_CIPHER : "AES/CBC/PKCS5Padding"
]

@Function(info="Get a SecretKeySpec from the hex encoded representation")
public SecretKey getSecretKey(String hexEncoded){
	if(hexEncoded == null || hexEncoded.trim().size()==0){
		throw new RuntimeException("You must provide a hex-encoded secret key to perform cryptography, set -DDEFAULT_CRYPTO_KEY={key} ;; generate a secure key by running /groovity/cryptoKeyGen")
	}
	cache(max:1000,key:hexEncoded,{
		map.each{ entry ->
			entry.value = new SecretKeySpec(parseHexBinary(entry.key),"AES");
		}
	})
}

@Function(info="returns a byte array that begins with a 16 byte IV followed by the encrypted payload")
public byte[] encrypt(byte[] data){
	encrypt(data,getSecretKey(conf.DEFAULT_CRYPTO_KEY),conf.DEFAULT_CRYPTO_CIPHER)
}

@Function(info="returns a byte array that begins with a 16 byte IV followed by the encrypted payload")
public byte[] encrypt(byte[] data, SecretKey secretKey){
	encrypt(data,secretKey,conf.DEFAULT_CRYPTO_CIPHER)
}

@Function(info="returns a byte array that begins with a 16 byte IV followed by the encrypted payload")
public byte[] encrypt(byte[] data, String hexEncodedKey){
	encrypt(data,getSecretKey(hexEncodedKey),conf.DEFAULT_CRYPTO_CIPHER)
}

@Function(info="returns a byte array that begins with a 16 byte IV followed by the encrypted payload")
@CompileStatic public byte[] encrypt(byte[] data, SecretKey secretKey, String cryptoCipher){
	byte[] iv = new byte[16];
	new SecureRandom().nextBytes(iv);
	IvParameterSpec ivSpec = new IvParameterSpec(iv);
	Cipher cipher = Cipher.getInstance(cryptoCipher);
	cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);
	byte[] encData = cipher.doFinal(data);
	byte[] rd = new byte[16+encData.length];
	System.arraycopy(iv,0,rd,0,16);
	System.arraycopy(encData,0,rd,16,encData.length);
	rd
}

@Function(info="takes a byte array that begins with a 16 byte IV followed by the encrypted payload, and returns the decrypted data")
public byte[] decrypt(byte[] data){
	decrypt(data,getSecretKey(conf.DEFAULT_CRYPTO_KEY),conf.DEFAULT_CRYPTO_CIPHER)
}

@Function(info="takes a byte array that begins with a 16 byte IV followed by the encrypted payload, and returns the decrypted data")
public byte[] decrypt(byte[] data, SecretKey secretKey){
	decrypt(data, secretKey, conf.DEFAULT_CRYPTO_CIPHER)
}

@Function(info="takes a byte array that begins with a 16 byte IV followed by the encrypted payload, and returns the decrypted data")
public byte[] decrypt(byte[] data, String hexEncodedKey){
	decrypt(data, getSecretKey(hexEncodedKey), conf.DEFAULT_CRYPTO_CIPHER)
}

@Function(info="takes a byte array that begins with a 16 byte IV followed by the encrypted payload, and returns the decrypted data")
@CompileStatic public byte[] decrypt(byte[] data, SecretKey secretKey, String cryptoCipher){
	IvParameterSpec ivSpec = new IvParameterSpec(data,0,16);
	Cipher cipher = Cipher.getInstance(cryptoCipher);
	cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);
	cipher.doFinal(data,16,data.length-16);
}

