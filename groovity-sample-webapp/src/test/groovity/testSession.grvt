/*******************************************************************************
 * Â© 2018 Disney | ABC Television Group
 *
 * Licensed under the Apache License, Version 2.0 (the "Apache License")
 * with the following modification; you may not use this file except in
 * compliance with the Apache License and the following modification to it:
 * Section 6. Trademarks. is deleted and replaced with:
 *
 * 6. Trademarks. This License does not grant permission to use the trade
 *     names, trademarks, service marks, or product names of the Licensor
 *     and its affiliates, except as required to comply with Section 4(c) of
 *     the License and to reproduce the content of the NOTICE file.
 *
 * You may obtain a copy of the Apache License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the Apache License with the above modification is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the Apache License for the specific
 * language governing permissions and limitations under the Apache License.
 *******************************************************************************/

import static javax.xml.bind.DatatypeConverter.printBase64Binary

static conf=[
	'groovity.port':int.class
]

def host = "http://localhost:${conf['groovity.port']}"

/**
 * Simulate a user session and validate data flow
 *
 * @author Alex Vigdor
 */
 
load('/data/factory');
// load and test the output as generated by the view
response = http(url:"${host}/")

assert response.contains('Notes')

def testUser =  factory('user','users?userName=testUser')?.first();
if(!testUser){
	//register test user
	http(method:"POST",url:"${host}/register",data:[userName:'testUser',password:'testPass'])
	factory.invalidate('user','users?userName=testUser')
	testUser = factory('user','users?userName=testUser').first();
	assert testUser.userName == 'testUser'
}
//set up digest credentials for re-use
def creds = <~<g:credentials user="testUser" pass="testPass"/>~>
//we'll also test using HMAC signing key for authentication
def sigCreds = <~<g:signature keyId="testUser" key="${testUser.signingKey}" headers="['(request-target)','host','date']"/> ~>

origData = [userId:testUser.id,message:"My first attempted note",worldRead:true];

//test UI first without credentials, expect 401
http(method:"POST",url:"${host}/secure",data:origData,{
	handler({
		assert httpResponse.statusLine.statusCode==401
	})
});
//now test UI POST with credentials
def firstResponse = http(method:"POST",url:"${host}/secure",data:origData,{creds()});
assert firstResponse.contains("first attempted")

//now test POST API
apiData = [userId:testUser.id,message:'I have API posted this private message']
http(
	method:"POST",
	url:"${host}/secure/notes",
	data:apiData,
	{
		header(name:'Content-Type',value:'application/json')
		handler({
			assert httpResponse.statusLine.statusCode==401
		})
	}
)
def newNoteUrl = http(
	method:"POST",
	url:"${host}/secure/notes",
	data:apiData,
	{
		creds()
		header(name:'Content-Type',value:'application/json')
		handler({
			assert httpResponse.statusLine.statusCode==201
			httpResponse.getFirstHeader("Location").value
		})
	}
)
//validate message survived round trip
def rtData = http(method:"GET",url:newNoteUrl,{creds()})

assert rtData.message==apiData.message
assert rtData.created != null

factory.invalidate('note','worldRead=1&orderBy=created+DESC&limit=10')
//validate public message appears in public api, private does not

def publicFeed = http(url:"${host}/notes")
assert publicFeed.find{ it.message.contains('first attempt') }
assert !publicFeed.find{ it.message.contains('private message') }

factory.invalidate('note',"userId=${testUser.id}")
def privateFeed = http(url:"${host}/secure/notes",{creds()})

assert privateFeed.find{ it.message.contains('first attempt') }
assert privateFeed.find{ it.message.contains('private message') }

//delete note and validate
http(method:'POST',data:[myNote_id:rtData.id,deleteNote:true],url:"${host}/secure",{creds()})
factory.invalidate('note',"userId=${testUser.id}")
privateFeed = http(url:"${host}/secure/notes",{creds()})
assert !privateFeed.find{ it.message.contains('private message') }

//Update and validate
def updateData = [message:"First pass"]
def updateNoteUrl = http(
	method:"POST",
	url:"${host}/secure/notes",
	data:updateData,
	{
		creds()
		header(name:'Content-Type',value:'application/json')
		handler({
			assert httpResponse.statusLine.statusCode==201
			httpResponse.getFirstHeader("Location").value
		})
	}
)
updateData.message = "I have API updated this personal message"
updateData.worldRead = true;

http(
	method:"PUT",
	url:updateNoteUrl,
	data:updateData,
	{
		creds()
		header(name:'Content-Type',value:'application/json')
		handler({
			assert httpResponse.statusLine.statusCode==204
		})
	}
)

def updateId = (updateNoteUrl =~ /\d+$/)[0]
factory.invalidate('note', updateId )

def rtData2 = http(method:"GET",url:updateNoteUrl,{creds()})
assert rtData2.message==updateData.message

//now test access using HTTP signature

def rtData3 = http(method:"GET",url:updateNoteUrl,{sigCreds()})
assert rtData3.message==updateData.message

//validate now publicly available

def publicCopy = http(url:"${host}/notes/${rtData2.id}",{})
assert publicCopy.message.contains('personal message')

//API delete and verify
http(method:"DELETE",url:updateNoteUrl,{sigCreds()})

factory.invalidate('note', updateId )

http(url:updateNoteUrl,{
	creds()
	handler({
		assert httpResponse.statusLine.statusCode == 404
	})
})

http(method:"GET",url:"${host}/secure/getKey",{
	creds()
	handler{
		assert httpResponse.entity.content.text.contains(printBase64Binary(testUser.decryptSecretKey()))
	}	
})

http(method:"GET",url:"${host}/secure/logout"){
	creds()
	handler({
		assert httpResponse.statusLine.statusCode==401
	})
}